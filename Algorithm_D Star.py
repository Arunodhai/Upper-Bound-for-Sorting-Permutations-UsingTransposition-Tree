# -*- coding: utf-8 -*-
"""Algo D star Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZAAo9y8sXr3OBSA6uwPodW2lbllpBdGp
"""

import networkx as nx
import numpy as np
from collections import Counter


global dist
dist = [[0 for x in range(300)] for y in range(300)]
global vis
vis = [300]
global dis
dis = [300]
global distsum
distsum = [300]
global distcount
distcount = [300]
global C
C={}




G = nx.Graph()


def create_TT():
  edges=[]
  node_count = int(input("Enter the number of vertices in the Transposition tree "))
  for i in range(1,(node_count+1)): #add the vertices
    G.add_node(i)
  print("Enter the edges ")
  for i in range(1,node_count): #add the edges
    t = tuple(map(int,input().split()))
    G.add_edge(*t)  
    edges.append(list(t))

  adjacency_matrix = nx.to_numpy_array(G)
  bfs(adjacency_matrix, node_count)


# function to create a Transposition tree
def checkStar(adjacency_matrix, node_count, count):
  
    vertexD1 = 0
    vertexDn_1 = 0

    for i in range(0, node_count):

        degreeI = 0
        for j in range(0, node_count):
            if (adjacency_matrix[i][j]==1):
                degreeI = degreeI + 1

        if (degreeI == 1):
            vertexD1 = vertexD1 + 1

        elif (degreeI == count - 1):
            vertexDn_1 = vertexDn_1 + 1


    return (vertexD1 == (count - 1) and
              vertexDn_1 == 1)


def bfs(adjacency_matrix, node_count):
  dist = [[0 for x in range(300)] for y in range(300)]
  tno = node_count
  for x in range(1,tno+1): #bfs is done from every vertex in order to obtain the shortest path from every vertex to every other vertex in the tree.
      dis = [0 for y in range(300)]
      vis = [0 for y in range(300)]
      queue = []
      queue.append(x)
      vis[x] = 1
      dis[x] = 0
      while (not (len(queue)==0)):
          tmp = queue[0]
          queue.pop(0)
          for y in range(1,tno+1):
              
              if ((adjacency_matrix[tmp-1][y-1] or adjacency_matrix[y-1][tmp-1]) and not (vis[y])):
                  vis[y] = 1
                  dis[y] = dis[tmp] + 1
                  queue.append(y)
              elif ((adjacency_matrix[tmp-1][y-1] or adjacency_matrix[y-1][tmp-1]) and vis[y] and dis[y] > dis[tmp] + 1):
                  dis[y] = dis[tmp] + 1

      for y in range(1,tno+1):
          if (vis[y] and (dist[x][y] == 0 or dist[x][y] > dis[y])):
              dist[x][y] = dis[y]

  distsum = [0 for x in range(300)]

  for x in range(1,tno+1):  #finding the distance-sum of each vertex.
      for y in range(1, tno+1):
          distsum[x] = distsum[x] + dist[x][y]
  
          
    
  algoDStar(adjacency_matrix, node_count,distsum,dist)
 
    
global s_nodelist1

def algoS(adjacency_matrix, node_count,distsum,dist,nodecount_temp):

  
  s_nodelist1=[]

  max1 = max(distsum)         #finding the node having maximum distance sum
  sourceNode = distsum.index(max1)
  Ecc = 0
  for x in range(1,nodecount_temp+1):       #finding the maximum eccentricity
      Ecc = max(Ecc, dist[sourceNode][x])
      
  
  #print("Ecc : ",Ecc)
  for x in range(1,nodecount_temp+1):
    for y in range(1,nodecount_temp+1):
       if (dist[x][y] == Ecc) :
          s_nodelist1.append(x)
          
  
  return (list(set(s_nodelist1)))


def algoNC(adjacency_matrix, node_count,distsum,dist,nodecount_temp):  

  merg_cnt = 0
  C ={}
  C[0]=list(algoS(adjacency_matrix, node_count,distsum,dist,nodecount_temp))
  C_sig={}
  C_sig[0]=list(algoS(adjacency_matrix, node_count,distsum,dist,nodecount_temp))


  max1 = max(distsum) 
  sourceNode = distsum.index(max1)
  diam = 0
  for x in range(1,nodecount_temp+1):       #finding the diameter
      diam = max(diam, dist[sourceNode][x])



  for i in range(1,(((diam+1)//2)-1)+1):
    C[i*2]=[]
    C_sig[i*2]=[]
  

  for i in range(1,(((diam+1)//2)-1)+1):
    C_sig[i*2]=C_sig[(i*2)-2][:]

    temp=C[(i*2)-2][:]
    for CA in temp:
      for CB in temp:
        if type(CA) is not list and type(CB) is not list :
          if dist[CA][CB] == i*2:
              C_AB=[CA,CB]
              C_sig[i*2].append(C_AB)
              C[i*2].append(C_AB)
              merg_cnt+=1


        elif type(CA) is list and type(CB) is list :
          for p in CA:
            for q in CB:
              if dist[p][q] == i*2:
                C_AB=[]
                for x in CA:
                  C_AB.append(x)
                for y in CB:
                  C_AB.append(y)
                C_sig[i*2].append(C_AB)
                C[i*2].append(C_AB)
                
                merg_cnt+=1






#to remove duplicate elements
    for w in range(1,len(C_sig[i*2])):
      if type(C_sig[i*2][w]) is list and type(C_sig[i*2][w-1]) is list :
        if sorted(C_sig[i*2][w]) == sorted(C_sig[i*2][w-1]):
           C_sig[i*2][w] = 0

    for w in range(1,len(C[i*2])): 
      if type(C[i*2][w]) is list and type(C[i*2][w-1]) is list :
        if sorted(C[i*2][w]) == sorted(C[i*2][w-1]):
           C[i*2][w-1] = 0


    val = 0
    try:
        while True:
            C_sig[i*2].remove(val)
            C[i*2].remove(val)
    except ValueError:
        pass


    temp=[]
    for j in C[i*2]:
      if j!=0:
          temp.append(j)
    C[i*2]=temp

  return C


def algoDStar(adjacency_matrix, node_count,distsum,dist):

   gamma=0
   count=0
   nodecount_temp=node_count
   
   if (checkStar(adjacency_matrix, nodecount_temp,node_count)):    #checks if the given tree is a star graph.
        gamma = gamma + 3 * (node_count - 1) // 2
        print("\nIs a star graph.")

   else:
        no=node_count
        while (no > 0):

          S=algoS(adjacency_matrix, node_count,distsum,dist,nodecount_temp)
          if not S:
            break
          CLs = algoNC(adjacency_matrix, node_count,distsum,dist,nodecount_temp)

          cstar_cnt=0

          for i,j in CLs.items():
            if j :
             cstartemp=j

          for i in cstartemp:
            cstar=i

          C=[]
          for i in S :
            if i not in cstar:
              C.append(i)

          

          max1 = max(distsum) 
          sourceNode = distsum.index(max1)
          diam = 0
          for x in range(1,nodecount_temp+1): #finding the diameter
              diam = max(diam, dist[sourceNode][x])

  


          if len(cstar) >= (len(S)/2):
            
            gamma =gamma + (len(C)*(diam))
           
            for y in C :
              distsum[y]=0
              tno=nodecount_temp
              for x in range(1,tno+1):  #making all its entries invalid in the distance matrix, updating the distsum and degree_count
                  if (not (x == y) and not (distsum[x] == 0)):
                      if (x < y):
                          distsum[x] = distsum[x] - dist[x][y]
                      else:
                          distsum[x] = distsum[x] - dist[x][y]

              for x in range(1,tno+1):
                    dist[y][x] = 0
                    dist[x][y] = 0
          
                    adjacency_matrix[y-1][x-1] = 0
                    adjacency_matrix[x-1][y-1] = 0

            
            no = no - len(C)
            node_count=node_count-len(C)
            cstar.clear()
            C.clear()
            S.clear()
                  

          elif len(cstar) < (len(S)/2):
           
            gamma =gamma + (len(cstar)*(diam))
          
            for y in C :
              distsum[y]=0
              tno=nodecount_temp
              for x in range(1,tno+1):  #making all its entries invalid in the distance matrix, updating the distsum and degree_count
                  if (not (x == y) and not (distsum[x] == 0)):
                      if (x < y):
                          distsum[x] = distsum[x] - dist[x][y]
                      else:
                          distsum[x] = distsum[x] - dist[x][y]

              for x in range(1,tno+1):
                    dist[y][x] = 0
                    dist[x][y] = 0
          
                    adjacency_matrix[y-1][x-1] = 0
                    adjacency_matrix[x-1][y-1] = 0

            if ((len(C)-len(cstar))%2==0) :
              gamma =gamma + ((len(C)-len(cstar))*((diam-(1/2))))
          
            else:
              gamma =gamma + ((len(C)-len(cstar))*((diam-(1/2))-(1/2)))
                    
            no = no - len(C)
            node_count=node_count-len(C)
            cstar.clear()
            C.clear()
            S.clear()
          
            

          if(checkStar(adjacency_matrix, nodecount_temp,node_count)):    #checks if the given tree is a star graph.
            gamma = gamma + 3 * (node_count - 1) // 2
            break

   print("\nUPPERBOUND :",gamma)
   return

create_TT()